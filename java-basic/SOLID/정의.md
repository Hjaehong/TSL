# SOLID

<aside>
💡 구현은 언제든지 유연하게 변경할 수 있도록 만드는 것이 좋은 객체 지향 설계이다.

</aside>

## S (SRP)

---

단일 책임 원칙 : 책임이라는 법위가 모호 하기때문에 풀어서 사용한다면 뭔가를 변경했을 때 파급이 적은걸 단일 책임이라고 한다

## O(OCP), 중요

---

개방 폐쇄원칙 : 확장에는 열려있어야 하지만 변경에는 닫혀있어야한다는 원칙 → 인터페이스 

**다형성을 활용하면 소프트웨어를 확장에는 열려있으나 변경에는 닫혀있게 할 수 있다**

근데 자바에서는 구현체를 변경하기 위해 구현 클래스를 바꿔줬는데 이건 원칙을 깨는 행위이다 

예를 들어 내가 아반떼를 타고 있는데 이번에 소나타로 바꿨다면

```java
public class car {
	
	
	private MyCar myCar = new Avante();

}
```

해당 코드로 변경하면 된다.

```java
public class car {
	
	
	//private MyCar myCar = new Avante();
	private MyCar myCar = new Sonata();
}
```

하지만 이건 아까 위에서 말한대로 원칙을 깨는 행위 인데 

변경에 닫혀있어야 OCP(개방폐쇄 원칙)을 잘 지키는 것이지만 해당 코드는 소나타로 바뀌면서 변경에 닫히질 않았다 

즉, 다형성을 사용했지만 OCP 원칙을 지킬 수 없다.

## L(LSP)

---

인터페이스 규약을 구현체에서 맘대로 변경하는거

→ 컴퓨터인터페이스를 구현하는 클래스 중에서 cpu구현 클래스가 있다면 내가 원하는대로 데이터를 저장하는 기능으로 변경할 수 없다

## I(ISP)

---

인터페이스 분리 원칙 : 인터페이스를 기능에 맞게 쪼개는것도 중요하다

→ 인터페이스를 너무 넓게 잡는것은 안좋다, 기능이 너무 많으면 복잡하기 때문에

## D(DIP)

---

의존관계 역전 원칙 : 추상화에 의존해라 구체화에 의존하지말고

→노트북 역할에 의존해야지 맥북이냐 그램이냐에 의지하면 안된다

클라이언트는 구현 클래스에 의존하지 말고, 인터페이스에 의존해야한다는 뜻

역할과 구현을 철저히 분리해야한다 

그런데 아까 OCP 예제 코드 처럼

`private MyCar myCar = new Sonata();` 해당 코드는 인터페이스에도 의존하지만 구현 클래스에도 의존한다.

> 의존한다는 건 무슨 의미 ?
알고 있다면 의존한다는 뜻
> 

car 클라이언트가 구현 클래스를 직접 선택한다. → DIP 위반

**즉 다형성 만으론 OCP,DIP를 지킬 수 없다**

# SPRING

---

스프링이 다형성에서만 지킬 수 없었던 OCP, DIP를 지키게 해준다.

- DI(Dependency Injection) : 의존성 주입
- DI 컨테이너 제공
- 클라이언트 코드의 변경 없이 기능 확장
- 부품 갈아 끼우듯이 개발